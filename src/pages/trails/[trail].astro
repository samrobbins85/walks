---
import type { GetStaticPaths } from "astro";
import { getTrails } from "../../utils/getTrails";
import Layout from "../../layouts/Layout.astro";
import { Icon } from "astro-icon/components";
import WalkCard from "../../components/walkCard.astro";
import fs from "node:fs/promises";
import path from "node:path";
import * as turf from "@turf/turf";
import TrailMap from "../../components/trailMap.astro";

export const getStaticPaths = (async () => {
  const sortedTrails = await getTrails();

  return sortedTrails.map((trail) => {
    const percentComplete = Math.round(
      (trail.data.completed / trail.data.length) * 100
    );
    const fileSlug = trail.filePath.split("/").at(-1).split(".")[0];
    return {
      params: { trail: trail.id },
      props: { trail: { ...trail, percentComplete }, fileSlug },
    };
  });
}) satisfies GetStaticPaths;

function findOverlapsOnPath(
  completePathCollection,
  walksCollections,
  bufferKm = 0.5
) {
  const completePath = completePathCollection.features[0];
  const mainCoords = completePath.geometry.coordinates;

  const covered = new Array(mainCoords.length).fill(false);

  walksCollections.forEach((walkCollection) => {
    walkCollection.features.forEach((walk) => {
      mainCoords.forEach((mainCoord, index) => {
        const mainPoint = turf.point(mainCoord);

        const isClose = walk.geometry.coordinates.some((walkCoord) => {
          const distance = turf.distance(mainPoint, turf.point(walkCoord), {
            units: "kilometers",
          });
          return distance < bufferKm;
        });

        if (isClose) {
          covered[index] = true;
        }
      });
    });
  });

  const overlaps = [];
  let currentSegment = [];

  mainCoords.forEach((coord, index) => {
    if (covered[index]) {
      currentSegment.push(coord);
    } else {
      if (currentSegment.length >= 2) {
        overlaps.push(turf.lineString(currentSegment));
      }
      currentSegment = [];
    }
  });

  if (currentSegment.length >= 2) {
    overlaps.push(turf.lineString(currentSegment));
  }

  return turf.featureCollection(overlaps);
}

const { trail, fileSlug } = Astro.props;
const filePath = path.join(
  process.cwd(),
  "src",
  "data",
  "trails",
  `${fileSlug}.json`
);
const fileContents = await fs.readFile(filePath, "utf-8");
const geojsonData = JSON.parse(fileContents);

const walkGeojsons = await Promise.all(
  trail.walks.map(async (walk) => {
    const walkFilePath = path.join(
      process.cwd(),
      "src",
      "data",
      "walks",
      walk.data.slug,
      "map.json"
    );
    const walkFileContents = await fs.readFile(walkFilePath, "utf-8");
    return JSON.parse(walkFileContents);
  })
);

const overlap = findOverlapsOnPath(geojsonData, walkGeojsons);
---

<Layout title={trail.data.name}>
  <div class="grid md:grid-cols-2 pt-6 gap-4">
    <div class="flex flex-col justify-center">
      <h1 class="text-4xl font-light mb-6">{trail.data.name}</h1>
      <h2>{trail.data.description}</h2>
      <div class="flex gap-x-4 pt-2">
        <span class="flex items-center gap-x-2 text-sm text-slate-500">
          <Icon name="lucide:route" class="size-4" />
          {trail.data.length}km</span
        >
        <span class="flex items-center gap-x-2 text-sm text-slate-500">
          <Icon name="lucide:footprints" class="size-4" />
          {trail.walks.length}
          {trail.walks.length === 1 ? "walk" : "walks"}</span
        >
      </div>
      {
        trail.data.completed && (
          <div class="pt-4 flex flex-col max-w-md">
            <span
              class={`text-xs font-medium pb-2 ${trail.percentComplete === 100 ? "text-green-600" : "text-sky-600"}`}
            >
              {trail.percentComplete === 100 ? "Completed" : "In progress"}
            </span>
            <div class="w-full h-2 bg-slate-200 rounded-full overflow-hidden">
              <div
                class={`h-full transition-all duration-300 ${trail.percentComplete === 100 ? "bg-green-600" : "bg-sky-600"}`}
                style={`width: ${trail.percentComplete}%;`}
              />
            </div>
            <span class="text-xs text-slate-600 pt-1">
              {trail.percentComplete}% complete
            </span>
          </div>
        )
      }
    </div>
    <div class="hidden md:block">
      <img
        src={trail.cover.src as any}
        alt=""
        class="w-full aspect-4/3 object-cover rounded-lg"
      />
    </div>
  </div>
  <div class="h-[400px] my-6">
    <TrailMap trailRoute={geojsonData} completedRoute={overlap} />
  </div>
  <div class="pt-4">
    <h2 class="text-2xl font-light mb-6">Walks</h2>
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 pb-8">
      {trail.walks.map((walk) => <WalkCard walk={walk} />)}
    </div>
  </div>
</Layout>
